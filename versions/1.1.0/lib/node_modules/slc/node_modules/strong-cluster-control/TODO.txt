## TODO:

- restart, won't work if size isn't set
- restart, restart while restart... does... what?

- master.shutdown/terminate of 'all' workers? --> setSize(0), except this does it in series...
- master.emit('error') - errors should NOT be emitted if no listener... they
  aren't that interesting
- disconnect, defaults to all, should allow specific
- command line interface to shutdown/terminate, all or id

- ability to customize env per worker

- add-workers [N]
- sub-workers [N]

- master rename to control
- ctl renamed to server

- status: connections/worker !! really want this

- configure ports and timeouts from package.json? DONE?

- write a worker description function W(w) { '#'+w.id+'['w.process.pid']' }

- Events:
  - events for setSize, and any other request that could be made by cli
  - events for when we try harder to shutdown/terminate

- master.exit that kills all the children, quickly or slowly, so they don't
  become orphaned, and examples attaching it to signals, and to
  process.on('exit', ?

- if a master is killed by signal... it leaves all its workers alive. kindof
  sucky.  we should terminate them.

- some kind of support for setting size, optionally, to os.cpus().length
- master.on('message', function(worker, msg) ...)

- Add all cluster events to master? Perhaps even all APIs?

## cluster-master does:

restart
resize
quitHard: SIGKILL every worker, and exit(1)
quit

SIGHUP -> restart
SIGINT -> quit
process.on(exit) -> quitHard unless quit called so exit is expected...

repl: connections, ?
repl: status: id, pid, state, age

minRestartAge(default=2000ms)/danger, if it looks like cluster isn't starting
up, it goes into danger state, and if all workers die (it goes to size 0), it
calls process.exit(1), if it reaches correct size, it clears danger. a bit hard
to follow exactly.

worker.kill() -> does process.kill(pid), not worker.kill()?

.on('fork')
  tracks all workers, their birth time (thus age), and redirects 'message' event
  to global

  attaches .on('exit')

      (clears disconnect timer)

      exit with not suicide considered abnormal

      exit triggers reevaluation of size, however,
        if !suicide, and if less < minAge, the resize is delayed 2secs

  attaches .on('disconnect')

    sets 5 sec timer... worker.process.kill(SIGKILL) after that


when it forks, it does worker.on('error', console.error)... what kind of errors?
what should I do?

restart process:

- wait for any current resize to finish
- notices when quit(stop) has been called, and stops the restart

get list of id of current (old) workers. shutdown one. on(resize), wait for new worker to be up for a while, repeat

## What can go wrong

- starting, we call fork, and:
  - suicides (explicit disconnect)
    - hm, why did it decide to do that? should we restart?
  - exits
    - suicide not set, so didn't exit because of disconnect
    - exit non-zero, probably bad
    - signal non-null, probably quite bad
  - if fork fails, we can keep trying, but why would the next one work?
    - life is strange... we could try a few times
      - XXX cluster-master does what?
    - code could have changed
      - we could retry a few times
  - fork failure comes in two varieties
    - within a timeout of .fork() - startup failure
    - later - runtime failure
      - obviously, the difference between them is arbitrary, though before
        'online', we definitely are in startup

- stopping, we call .disconnect, and
  - we get 'disconnect', that means channel is closed
    - we get exit, so its stopped (but maybe weirdly, see code and signal)
    - we don't get exit, so its not stopping
      - we can ignore, or we can kill...
